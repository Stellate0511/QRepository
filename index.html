<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>å›¾çµç®±</title>

    <!-- å¤–éƒ¨ä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/fflate"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            background-color: #f7f9fc;
            margin: 0;
            color: #333;
        }

        header {
            background-color: #1976d2;
            color: white;
            text-align: center;
            padding: 1em;
        }

        #status {
            margin-top: 0.5em;
            font-size: 0.9em;
        }

        nav {
            background-color: #e3f2fd;
            display: flex;
            justify-content: center;
            padding: 10px;
        }

        nav button {
            margin: 0 10px;
            padding: 10px 20px;
            font-size: 1em;
            color: #1976d2;
            background-color: white;
            border: 1px solid #90caf9;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        nav button:hover {
            background-color: #e0ecff;
        }

        /* æ¿€æ´»æ ·å¼ */
        #embedTab.active,
        #extractTab.active {
            background-color: #1976d2;
            color: white;
            border-color: #1976d2;
            box-shadow: 0 0 4px #1976d280;
        }

        .tab {
            display: none;
            padding: 30px 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .tab.active {
            display: block;
        }

        section h2 {
            text-align: center;
            color: #1976d2;
        }

        .form-group {
            margin: 15px 0;
            text-align: center;
        }

        .form-group input,
        .form-group textarea,
        .form-group button,
        .form-group label {
            font-size: 1em;
            margin: 5px auto;
        }

        .inline {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            justify-content: center;
        }

        canvas {
            max-width: 90%;
            width: 300px;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #ccc;
        }

        footer {
            background-color: #f1f1f1;
            text-align: center;
            padding: 10px;
            font-size: 0.9em;
            color: #777;
        }

        .file-label {
            display: inline-block;
            background-color: #1976d2;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .file-label:hover {
            background-color: #125ba6;
        }

        #filesInputName,
        #previewImageName {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
            text-align: center;
        }
    </style>
</head>

<body>
    <header>
        <h1>å›¾çµç®±</h1>
        <h3 style="margin-top:-20px">QRepository</h3>
        <div id="status">â³ æ­£åœ¨åŠ è½½ä¾èµ–åº“ï¼Œè¯·ç¨å€™â€¦</div>
    </header>

    <nav>
        <button id="extractTab" class="active" onclick="switchTab('decoder')">ğŸ“¥ æ–‡ä»¶æå–</button>
        <button id="embedTab" onclick="switchTab('encoder')">ğŸ” æ–‡ä»¶åµŒå…¥</button>
    </nav>

    <!-- è§£ç é¡µï¼ˆé»˜è®¤ï¼‰ -->
    <section id="decoder" class="tab active">
        <h2>ğŸ“¥ æ–‡ä»¶æå–</h2>

        <div class="form-group">
            <label for="imageInput" class="file-label">ğŸ–¼ï¸ é€‰æ‹©äºŒç»´ç å›¾åƒ</label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;" />
            <div id="imageInputName">æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡</div>
        </div>

        <div class="form-group">
            <button id="decodeButton"">æå–æ–‡ä»¶</button>
        </div>

        <!-- è§£ç é¡µè¿›åº¦æ¡ -->
        <div id="decodeProgressWrap" style="display:none; max-width:600px; margin:8px auto;">
                <div id="decodeProgressText" style="text-align:center; font-size:0.9em; margin-bottom:6px;">å‡†å¤‡ä¸­â€¦</div>
                <div style="height:10px; background:#eee; border-radius:6px; overflow:hidden;">
                    <div id="decodeProgressBar" style="height:10px; width:0%; background:#1976d2;"></div>
                </div>
        </div>

        <div id="fileList" class="form-group"></div>
    </section>

    <!-- ç¼–ç é¡µ -->
    <section id="encoder" class="tab">
        <h2>ğŸ” æ–‡ä»¶åµŒå…¥</h2>

        <div class="form-group">
            <label for="filesInput" class="file-label">ğŸ“ é€‰æ‹©è¦åµŒå…¥çš„æ–‡ä»¶</label>
            <input type="file" id="filesInput" multiple style="display:none;" />
            <div id="filesInputName">æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶</div>
        </div>

        <div class="form-group">
            <label for="qrLinkSelect">åµŒå…¥äºŒç»´ç é“¾æ¥ï¼š</label>
            <select id="qrLinkSelect">
                <option value="https://s2js.com/Stellate/QRepository" selected>S2JS é¡µé¢</option>
                <option value="https://stellate0511.github.io/QRepository/">Github é¡µé¢</option>
            </select>
        </div>


        <div class="form-group">
            <label for="embedMode">åµŒå…¥ç­–ç•¥ï¼š</label>
            <select id="embedMode">
                <option value="scanbest" selected>æœ€å¥½æ‰«æï¼ˆæ¨èï¼‰</option>
                <option value="maxdata">æœ€å°å›¾ç‰‡ï¼ˆå¯èƒ½éœ€è¦å¯¹ç€å±å¹•æ‰«æï¼‰</option>
            </select>
        </div>

        <div class="form-group">
            <input type="checkbox" id="extraInfoToggle" />
            <label for="extraInfoToggle">é™„åŠ æè¿°å›¾ç‰‡å’Œæ–‡æœ¬</label>
        </div>

        <div id="extraInfoContainer" style="display: none;">
            <div class="form-group">
                <label for="previewImageInput" class="file-label">ğŸ–¼ï¸ ä¸Šä¼ æè¿°å›¾ç‰‡ï¼ˆä¼šæ˜¾ç¤ºåœ¨äºŒç»´ç ä¸‹æ–¹ï¼‰</label>
                <input type="file" id="previewImageInput" accept="image/*" style="display:none;" />
                <div id="previewImageName">æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡</div>
                <button type="button" id="clearPreviewImageButton" style="margin-top: 10px;">âŒ æ¸…é™¤æè¿°å›¾ç‰‡</button>
            </div>
            <div class="form-group">
                <input type="text" id="descriptionInput" p placeholder="è¾“å…¥æè¿°æ–‡å­—ï¼ˆä¼šæ˜¾ç¤ºåœ¨äºŒç»´ç ä¸‹æ–¹ï¼‰" rows="3"
                    style="width: 90%; max-width: 400px;"></textarea>
            </div>
        </div>

        <div class="form-group">
            <button id="generateButton"">ç”ŸæˆäºŒç»´ç å›¾åƒ</button>
        </div>

        <!-- ç¼–ç é¡µè¿›åº¦æ¡ -->
        <div id="encodeProgressWrap" style="display:none; max-width:600px; margin:8px auto;">
                <div id="encodeProgressText" style="text-align:center; font-size:0.9em; margin-bottom:6px;">å‡†å¤‡ä¸­â€¦</div>
                <div style="height:10px; background:#eee; border-radius:6px; overflow:hidden;">
                    <div id="encodeProgressBar" style="height:10px; width:0%; background:#1976d2;"></div>
                </div>
        </div>

        <canvas id="qrCanvas" width="512" height="512" style="max-width: 90%; height: auto; display: none;"></canvas>
        <div id="qrPreviewContainer" class="form-group"></div>
        <div class="form-group">
            <a id="downloadLink" style="display: none;">ğŸ“¥ ä¸‹è½½äºŒç»´ç å›¾åƒ</a>
        </div>
    </section>

    <footer>
        æœ¬å·¥å…·è¿è¡Œäºæµè§ˆå™¨æœ¬åœ°ï¼Œæ— éœ€è”ç½‘ï¼Œæ‰€æœ‰æ•°æ®å¤„ç†å‡ä¸ä¸Šä¼ ã€‚
        <br>Â© ç‚¹ç¼€æ˜Ÿç©º 2025
    </footer>

    <script>
        document.getElementById("generateButton").onclick = async function () {
            const files = document.getElementById("filesInput").files;
            if (files.length === 0) {
                alert("è¯·é€‰æ‹©æ–‡ä»¶");
                return;
            }

            const button = document.getElementById("generateButton");
            // ç¦ç”¨æŒ‰é’®å¹¶æ”¹æ–‡å­—
            button.disabled = true;
            const originalText = button.innerText;
            button.innerText = "å¤„ç†ä¸­â€¦";

            try {
                await generateDataQRCodeFromFiles(files);
            } catch (err) {
                console.error(err);
                alert("å¤„ç†å¤±è´¥ï¼š" + err.message);
            }

            // æ¢å¤æŒ‰é’®
            button.disabled = false;
            button.innerText = originalText;
        };

        function zipFilesAsync(fileList) {
            return new Promise((resolve, reject) => {
                const entries = {};
                let readDone = 0;
                const total = fileList.length;
                if (total === 0) return resolve(new Uint8Array());

                for (const file of fileList) {
                    const fr = new FileReader();
                    fr.onload = async () => {
                        entries[file.name] = new Uint8Array(fr.result);
                        readDone++;
                        setProgress("encode", Math.floor((readDone / total) * 40), `è¯»å–æ–‡ä»¶â€¦(${readDone}/${total})`);
                        if (readDone === total) {
                            // å¼‚æ­¥ zipï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
                            setProgress("encode", 45, "å‹ç¼©ä¸­â€¦");
                            await uiTick();
                            fflate.zip(entries, { level: 9 }, (err, zipped) => {
                                if (err) return reject(err);
                                setProgress("encode", 60, "å‹ç¼©å®Œæˆ");
                                resolve(zipped);
                            });
                        }
                    };
                    fr.onerror = () => reject(new Error(`æ— æ³•è¯»å–æ–‡ä»¶: ${file.name}`));
                    fr.readAsArrayBuffer(file);
                }
            });
        }

        async function composeFinalQRCodeCanvas(qrCanvas) {
            const useExtra = document.getElementById("extraInfoToggle").checked;
            if (!useExtra) return qrCanvas;

            const n = qrCanvas.width; // assume square
            const extraHeight = Math.floor(n * 0.25);
            const totalHeight = n + extraHeight;

            const finalCanvas = document.createElement("canvas");
            finalCanvas.width = n;
            finalCanvas.height = totalHeight;

            const ctx = finalCanvas.getContext("2d");

            // èƒŒæ™¯ç™½
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, n, totalHeight);

            // ç»˜åˆ¶äºŒç»´ç ä¸»ä½“
            ctx.drawImage(qrCanvas, 0, 0);

            // è·å–é™„åŠ ä¿¡æ¯
            const previewImageFile = document.getElementById("previewImageInput").files[0];
            const descriptionText = document.getElementById("descriptionInput").value.trim();

            // è‹¥æ²¡æœ‰æè¿°å›¾ç‰‡ï¼Œåˆ™è®©æ–‡æœ¬å±…ä¸­æ˜¾ç¤º
            if (!previewImageFile) {
                if (descriptionText !== "") {
                    const maxWidth = 0.9 * n;
                    const maxHeight = 0.1 * n;

                    let fontSize = 1;
                    while (true) {
                        ctx.font = `${fontSize + 1}px sans-serif`;
                        const metrics = ctx.measureText(descriptionText);
                        const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        const textWidth = metrics.width;
                        if (textHeight > maxHeight || textWidth > maxWidth) break;
                        fontSize++;
                    }

                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.fillStyle = "#000";
                    ctx.textBaseline = "middle";
                    ctx.textAlign = "center";
                    ctx.fillText(descriptionText, n / 2, n + extraHeight / 2);
                }

                return finalCanvas;
            }

            return new Promise((resolve) => {
                // æœ‰æè¿°å›¾ç‰‡ â†’ éœ€è¦å¼‚æ­¥åŠ è½½å›¾ç‰‡åç»˜åˆ¶
                const img = new Image();
                const reader = new FileReader();

                reader.onload = function () {
                    img.onload = function () {
                        // æè¿°å›¾ä½ç½®ï¼šå·¦ä¸‹è§’ 0.2n x 0.2n
                        const boxSize = n * 0.2;
                        const boxX = 0;
                        const boxY = n + (extraHeight - boxSize) / 2;

                        let imgW = img.width;
                        let imgH = img.height;
                        const scale = Math.min(boxSize / imgW, boxSize / imgH);
                        imgW *= scale;
                        imgH *= scale;

                        // è®¡ç®—å±…ä¸­ç»˜åˆ¶çš„èµ·ç‚¹
                        const drawX = boxX + (boxSize - imgW) / 2;
                        const drawY = boxY + (boxSize - imgH) / 2;

                        ctx.drawImage(img, drawX, drawY, imgW, imgH);

                        // æè¿°æ–‡å­—ä½ç½®ï¼šå³ä¸‹è§’ 0.7n x 0.1n
                        if (descriptionText !== "") {
                            const boxWidth = n * 0.7;
                            const boxHeight = n * 0.1;
                            const boxX = n * 0.25;
                            const boxY = n + (extraHeight - boxHeight) / 2;

                            let fontSize = 1;
                            while (true) {
                                ctx.font = `${fontSize + 1}px sans-serif`;
                                const metrics = ctx.measureText(descriptionText);
                                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                                const textWidth = metrics.width;
                                if (textHeight > boxHeight || textWidth > boxWidth) break;
                                fontSize++;
                            }

                            ctx.font = `${fontSize}px sans-serif`;
                            ctx.fillStyle = "#000";
                            ctx.textBaseline = "middle";
                            ctx.textAlign = "left";
                            ctx.fillText(descriptionText, boxX, boxY + boxHeight / 2);
                        }
                        resolve(finalCanvas);
                    };
                    img.src = reader.result;
                };

                reader.readAsDataURL(previewImageFile);
            });
        }

        async function generateDataQRCodeFromFiles(fileList) {
            try {
                // === 0. å¯åŠ¨è¿›åº¦æ¡ === // NEW
                setProgress("encode", 1, "å‡†å¤‡å¼€å§‹â€¦");
                await uiTick();

                // 1. å°†å¤šä¸ªæ–‡ä»¶å‹ç¼©ä¸º zip Uint8Array
                setProgress("encode", 4, "å‹ç¼©æ–‡ä»¶â€¦"); // NEW
                const zipped = await zipFilesAsync(fileList);
                await uiTick(); // NEW

                // 2. æ„é€ å®Œæ•´æ•°æ®ï¼š[ç‰ˆæœ¬(1)][ç­–ç•¥(1)][æ ¡éªŒ(1)][qrSize(3)][zippedLength(4)][æ•°æ®]
                const mode = document.getElementById("embedMode").value;
                let usablePixelFilter;
                let pixelRatio;
                let strategyByte;
                switch (mode) {
                    case "scanbest":
                        usablePixelFilter = (x, y) => (x + y) % 2 !== 1;
                        strategyByte = 0xFF;
                        pixelRatio = 2;
                        break;
                    case "maxdata":
                        usablePixelFilter = (x, y) => (x + y) % 3 !== 2;
                        strategyByte = 0xFE;
                        pixelRatio = 1.5;
                        break;
                    default:
                        throw new Error("æœªçŸ¥åµŒå…¥æ¨¡å¼");
                }

                const versionByte = 0x01;
                const checksum = zipped.reduce((acc, b) => acc ^ b, 0) & 0xff;
                const zippedLength = zipped.length;
                const fullLength = 10 + zippedLength;
                const fullData = new Uint8Array(fullLength);
                fullData[0] = versionByte;
                fullData[1] = strategyByte;
                fullData[2] = checksum;

                // 3. è®¡ç®—éœ€è¦å¤šå°‘åƒç´ æ¥å­˜å‚¨æ•°æ®
                setProgress("encode", 8, "è®¡ç®—å°ºå¯¸ä¸å¤´éƒ¨â€¦"); // NEW
                const byteCount = fullLength;
                const neededPixels = Math.ceil(byteCount / 3); // æ¯ä¸ªåƒç´ 3ä¸ªé€šé“
                const actualPixels = Math.ceil(pixelRatio * neededPixels);
                const side = Math.ceil(Math.sqrt(actualPixels));
                const qrSize = Math.max(512, side); // ä¿åº•å¤§å°ä¸º512px

                // 3~5: qrSizeï¼ˆé«˜ä½åœ¨å‰ï¼‰
                fullData[3] = (qrSize >> 16) & 0xFF;
                fullData[4] = (qrSize >> 8) & 0xFF;
                fullData[5] = qrSize & 0xFF;

                // 6~9: zippedLengthï¼ˆé«˜ä½åœ¨å‰ï¼‰
                fullData[6] = (zippedLength >>> 24) & 0xFF;
                fullData[7] = (zippedLength >>> 16) & 0xFF;
                fullData[8] = (zippedLength >>> 8) & 0xFF;
                fullData[9] = zippedLength & 0xFF;
                fullData.set(zipped, 10);
                await uiTick(); // NEW

                // 4. ç”ŸæˆäºŒç»´ç  canvasï¼ˆåº•å›¾ï¼‰
                setProgress("encode", 12, "ç”ŸæˆåŸºç¡€äºŒç»´ç â€¦"); // NEW
                const canvas = document.createElement("canvas");
                canvas.width = qrSize;
                canvas.height = qrSize;

                const selectedURL = document.getElementById("qrLinkSelect").value;
                await new Promise((resolve, reject) => {
                    QRCode.toCanvas(canvas, selectedURL, {
                        errorCorrectionLevel: "H",
                        margin: 1,
                        width: qrSize,
                    }, (err) => {
                        if (err) reject(err);
                        else resolve();
                    });
                });
                await uiTick(); // NEW

                // 5. å†™å…¥æ•°æ®åˆ°åƒç´ ï¼ˆä¸»è€—æ—¶ï¼›ä¸»è¿›åº¦åŒºé—´ 12% â†’ 92%ï¼‰
                setProgress("encode", 20, "å†™å…¥æ•°æ®åˆ°åƒç´ â€¦"); // NEW
                const ctx = canvas.getContext("2d");
                const imgData = ctx.getImageData(0, 0, qrSize, qrSize);
                const pixels = imgData.data;

                // è®¡ç®—æœ€å¤§å¯å†™å­—èŠ‚ï¼ˆç”¨äºå‡†ç¡®è¿›åº¦ï¼‰
                // å¯ç”¨åƒç´  â‰ˆ ç­›é€‰é€šè¿‡çš„åƒç´ æ•° Ã— 3 é€šé“ï¼Œå†ä¸ fullData.length å–æœ€å°å€¼
                let usablePixelCount = 0;
                for (let y = 0; y < qrSize; y++) {
                    for (let x = 0; x < qrSize; x++) {
                        if (usablePixelFilter(x, y)) usablePixelCount++;
                    }
                }
                const maxWritableBytes = Math.min(fullData.length, usablePixelCount * 3);
                const startPct = 20, endPct = 92; // å†™å…¥é˜¶æ®µçš„è¿›åº¦åŒºé—´
                const pctSpan = endPct - startPct;
                let dataIndex = 0;
                let lastReport = 0;

                // æ¯å†™å…¥è‹¥å¹²å­—èŠ‚å°±åˆ·æ–°ä¸€æ¬¡ UI
                const report = () => {
                    const wrote = Math.min(dataIndex, maxWritableBytes);
                    if (wrote - lastReport >= 8192 || wrote === maxWritableBytes) {
                        lastReport = wrote;
                        const frac = wrote / maxWritableBytes;
                        const pct = startPct + Math.floor(frac * pctSpan);
                        setProgress("encode", pct, `å†™å…¥æ•°æ®â€¦ (${wrote}/${maxWritableBytes} å­—èŠ‚)`);
                    }
                };

                for (let y = 0; y < qrSize; y++) {
                    for (let x = 0; x < qrSize; x++) {
                        if (usablePixelFilter(x, y)) {
                            const idx = (y * qrSize + x) * 4;

                            // ä¸ºäº†å‡†ç¡®ç»Ÿè®¡å†™å…¥çš„çœŸå®æ•°æ®é‡ï¼Œåªåœ¨ dataIndex < fullData.length æ—¶è®¡å…¥
                            const before = dataIndex;

                            pixels[idx] = dataIndex < fullData.length ? fullData[dataIndex++] : Math.floor(Math.random() * 256);
                            pixels[idx + 1] = dataIndex < fullData.length ? fullData[dataIndex++] : Math.floor(Math.random() * 256);
                            pixels[idx + 2] = dataIndex < fullData.length ? fullData[dataIndex++] : Math.floor(Math.random() * 256);
                            // alpha ä¿æŒä¸å˜

                            // å¦‚æœè¿™æ¬¡ç¡®å®å†™å…¥äº†æ•°æ®ï¼Œå°±å°è¯•æŠ¥å‘Š
                            if (dataIndex !== before) report();

                            // è½»é‡è®©å‡ºä¸»çº¿ç¨‹ï¼Œé¿å…å¡ UIï¼ˆæŒ‰è¡Œæˆ–æ¯è‹¥å¹²åƒç´ ï¼‰
                            // è¿™é‡ŒæŒ‰åˆ—æ­¥è¿›ï¼Œå¯ä»¥æ”¹æˆ (x & 255) === 0 æ ¹æ®éœ€è¦è°ƒæ•´
                        }
                    }
                    if ((y & 7) === 0) { // æ¯ 8 è¡Œè®©ä¸€æ¬¡
                        await uiTick(); // NEW
                    }
                }

                ctx.putImageData(imgData, 0, 0);
                setProgress("encode", 94, "åˆæˆå±•ç¤ºâ€¦"); // NEW
                await uiTick(); // NEW

                // 6. æ˜¾ç¤ºä¸å¯¼å‡º
                const preview = document.getElementById("qrPreviewContainer");
                preview.innerHTML = "";

                const composed = await composeFinalQRCodeCanvas(canvas);
                preview.appendChild(composed);

                // è®¾ç½®è‡ªé€‚åº”å®½åº¦
                const displayWidth = 300;
                const ratio = composed.height / composed.width;
                composed.style.width = `${displayWidth}px`;
                composed.style.height = `${displayWidth * ratio}px`;
                composed.style.display = "block";
                composed.style.margin = "10px auto";

                // ä¸‹è½½é“¾æ¥è®¾ç½®
                const link = document.getElementById("downloadLink");
                link.style.display = "none";

                setProgress("encode", 96, "æ­£åœ¨ç¼–ç  PNGâ€¦"); // å·²æœ‰
                await uiTick();

                composed.toBlob((blob) => {
                    if (!blob) { alert("PNG ç¼–ç å¤±è´¥"); hideProgress("encode", "å¤±è´¥"); return; } // NEW: å¤±è´¥æ—¶å…³é—­
                    const url = URL.createObjectURL(blob);
                    link.href = url;
                    link.download = "qr_encoded.png";
                    link.style.display = "inline-block";
                    link.onclick = () => setTimeout(() => URL.revokeObjectURL(url), 2000);
                    hideProgress("encode", "å®Œæˆ"); // å®Œæˆ
                }, "image/png");
            } catch (err) {
                console.error(err);
                alert(`ç¼–ç å¤±è´¥ï¼š${err.message || err}`);
                hideProgress("encode", "å¤±è´¥"); // NEW
            }
        }

        function switchTab(mode) {
            const decoderButton = document.getElementById("extractTab");
            const encoderButton = document.getElementById("embedTab");

            const decoderSection = document.getElementById("decoder");
            const encoderSection = document.getElementById("encoder");

            if (mode === "decoder") {
                decoderButton.classList.add("active");
                encoderButton.classList.remove("active");

                decoderSection.classList.add("active");
                encoderSection.classList.remove("active");
            } else if (mode === "encoder") {
                encoderButton.classList.add("active");
                decoderButton.classList.remove("active");

                encoderSection.classList.add("active");
                decoderSection.classList.remove("active");
            }
        }

        document.getElementById("decodeButton").onclick = async function () {
            const input = document.getElementById("imageInput");
            const file = input.files && input.files[0];
            if (!file) {
                alert("è¯·å…ˆé€‰æ‹©äºŒç»´ç å›¾ç‰‡");
                return;
            }

            const button = document.getElementById("decodeButton");
            button.disabled = true;
            const originalText = button.innerText;
            button.innerText = "å¤„ç†ä¸­â€¦";

            try {
                await decodeQRCode(file, button, originalText);
            } catch (err) {
                console.error(err);
                alert("å¤„ç†å¤±è´¥ï¼š" + err.message);
                // å‡ºé”™æ—¶è¿™é‡Œå¯ä»¥å…œåº•æ¢å¤æŒ‰é’®
                button.disabled = false;
                button.innerText = originalText;
            }
        };

        async function decodeQRCode(file, button, originalText) {
            const cancel = (msg) => {
                if (msg) alert(msg);
                hideProgress("decode", "å·²å–æ¶ˆ");
            };
            const finish = (msg) => hideProgress("decode", msg || "å®Œæˆ");

            const workerSrc = `
    self.onmessage = async (e) => {
      const msg = e.data || {};
      if (msg.type === 'scan') {
        try {
          const { width, height, pixelsBuf } = msg;
          const pixels = new Uint8ClampedArray(pixelsBuf);

          const version  = pixels[0] | 0;
          const strategy = pixels[1] | 0;
          const checksum = pixels[2] | 0;

          if (version !== 0x01 || (strategy !== 0xFF && strategy !== 0xFE)) {
            self.postMessage({ type:'error', message: 'ç‰ˆæœ¬å·æˆ–ç­–ç•¥æ— æ•ˆã€‚å›¾åƒå¯èƒ½å·²è¢«å‹ç¼©ï¼Œå»ºè®®ä½¿ç”¨åŸå›¾ã€‚' });
            return;
          }

          let usable;
          if (strategy === 0xFF) usable = (x,y)=>((x+y)%2!==1);
          else if (strategy === 0xFE) usable = (x,y)=>((x+y)%3!==2);

          const head = new Uint8Array(10);
          head[0]=version; head[1]=strategy; head[2]=checksum;
          let hpos = 3, lastX = 0, lastY = 0;
          outerHead:
          for (let y=0; y<height; y++) {
            for (let x=(y===0?1:0); x<width; x++) {
              if (!usable(x,y)) continue;
              const idx=(y*width+x)*4;
              if (hpos<10) head[hpos++]=pixels[idx];
              if (hpos<10) head[hpos++]=pixels[idx+1];
              if (hpos<10) head[hpos++]=pixels[idx+2];
              if (hpos>=10) { lastX=x; lastY=y; break outerHead; }
            }
          }
          if (hpos<10) {
            self.postMessage({type:'error',message:'æœªèƒ½è¯»å–å®Œæ•´å¤´éƒ¨ï¼ˆå‰10å­—èŠ‚ï¼‰ã€‚å›¾åƒå¯èƒ½å·²è¢«å‹ç¼©æˆ–ç¼©æ”¾ã€‚'});
            return;
          }

          const qrSize = ((head[3]<<16)|(head[4]<<8)|head[5])>>>0;
          const zippedLength = ((((head[6]<<24)>>>0)|(head[7]<<16)|(head[8]<<8)|head[9])>>>0)>>>0;
          const needTotal = 10 + zippedLength;

          self.postMessage({ type:'head', qrSize, zippedLength });

          const ok = await new Promise(res=>{
            const h=(ev)=>{ if (ev.data && ev.data.type==='head-ack') { self.removeEventListener('message',h); res(!!ev.data.proceed); } };
            self.addEventListener('message', h);
          });
          if (!ok) { self.postMessage({type:'cancelled'}); return; }

          const fullData = new Uint8Array(needTotal);
          fullData.set(head,0);
          let pos=10;

          const idx=(lastY*width+lastX)*4;
          const used = ( (hpos-3) % 3 );
          if (used===1) { if (pos<needTotal) fullData[pos++]=pixels[idx+1]; if (pos<needTotal) fullData[pos++]=pixels[idx+2]; }
          else if (used===2) { if (pos<needTotal) fullData[pos++]=pixels[idx+2]; }

          const limitW=Math.min(width, qrSize), limitH=Math.min(height, qrSize);
          let lastReport=0;
          const report=()=>{ const got=pos; if (got-lastReport>=10000 || got>=needTotal) { lastReport=got; self.postMessage({type:'progress', got, total:needTotal}); } };

          for (let y=lastY; y<limitH; y++) {
            for (let x=(y===lastY?lastX+1:0); x<limitW; x++) {
              if (!usable(x,y)) continue;
              const idx=(y*width+x)*4;
              if (pos<needTotal) fullData[pos++]=pixels[idx]; else break;
              if (pos<needTotal) fullData[pos++]=pixels[idx+1]; else break;
              if (pos<needTotal) fullData[pos++]=pixels[idx+2]; else break;
              report();
              if (pos>=needTotal) break;
            }
            report();
          }

          if (pos<needTotal) {
            self.postMessage({type:'error',message:'å¯ç”¨åƒç´ ä¸è¶³ï¼šéœ€ '+needTotal+' å­—èŠ‚ï¼Œä»…è· '+pos+' å­—èŠ‚ã€‚å›¾åƒå¯èƒ½ç»è¿‡å‹ç¼©ï¼Œå»ºè®®ä½¿ç”¨åŸå›¾ã€‚'});
            return;
          }
          self.postMessage({ type:'done', fullData: fullData.buffer }, [fullData.buffer]);
        } catch (err) {
          self.postMessage({ type:'error', message: err?.message || String(err) });
        }
      }
    };`;

            const worker = new Worker(URL.createObjectURL(new Blob([workerSrc], { type: 'application/javascript' })));

            const url = URL.createObjectURL(file);
            let bitmap;
            try {
                bitmap = await createImageBitmap(file, { imageOrientation: 'none', premultiplyAlpha: 'none', colorSpaceConversion: 'none' });
            } catch {
                bitmap = null;
            }

            const drawAndScan = async () => {
                try {
                    setProgress("decode", 1, "è¯»å–å›¾åƒåƒç´ â€¦");
                    await uiTick();
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d", { willReadFrequently: true });
                    let width, height;

                    if (bitmap) {
                        width = canvas.width = bitmap.width;
                        height = canvas.height = bitmap.height;
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(bitmap, 0, 0);
                    } else {
                        const img = new Image();
                        img.src = url;
                        await new Promise((res, rej) => { img.onload = () => res(); img.onerror = () => rej(new Error("å›¾ç‰‡åŠ è½½å¤±è´¥")); });
                        width = canvas.width = img.naturalWidth || img.width;
                        height = canvas.height = img.naturalHeight || img.height;
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                    }

                    const imgData = ctx.getImageData(0, 0, width, height);
                    const buf = imgData.data.buffer;

                    worker.onmessage = async (ev) => {
                        const m = ev.data || {};
                        if (m.type === 'head') {
                            const { qrSize, zippedLength } = m;
                            if (zippedLength > 50 * 1024 * 1024) {
                                const proceed = confirm(`âš ï¸ æ•°æ®å¤§å°ä¸º ${formatBytes(zippedLength)}ï¼Œå¯èƒ½åŠ è½½ç¼“æ…¢æˆ–å¤±è´¥ã€‚\næ˜¯å¦ä»è¦ç»§ç»­ï¼Ÿ`);
                                worker.postMessage({ type: 'head-ack', proceed });
                                if (!proceed) {
                                    worker.terminate();
                                    URL.revokeObjectURL(url);
                                    cancel("ç”¨æˆ·å–æ¶ˆäº†è§£ç ã€‚");

                                    if (button) {
                                        button.disabled = false;
                                        button.innerText = originalText;
                                    }
                                    return;
                                }

                            } else {
                                worker.postMessage({ type: 'head-ack', proceed: true });
                            }
                        } else if (m.type === 'progress') {
                            const p = 8 + Math.floor((m.got / m.total) * 62);
                            setProgress("decode", p, `æ‰«ææ•°æ®â€¦ (${m.got}/${m.total} å­—èŠ‚)`);
                        } else if (m.type === 'error') {
                            worker.terminate(); URL.revokeObjectURL(url);
                            alert('æå–å¤±è´¥ï¼š' + m.message);
                            hideProgress("decode", "å¤±è´¥");

                            if (button) {
                                button.disabled = false;
                                button.innerText = originalText;
                            }
                        } else if (m.type === 'cancelled') {
                            worker.terminate(); URL.revokeObjectURL(url);
                            cancel("ç”¨æˆ·å–æ¶ˆäº†è§£ç ã€‚");

                            if (button) {
                                button.disabled = false;
                                button.innerText = originalText;
                            }
                        } else if (m.type === 'done') {
                            worker.terminate(); URL.revokeObjectURL(url);

                            const fullData = new Uint8Array(m.fullData);
                            const version = fullData[0], strategy = fullData[1], checksum = fullData[2];
                            const zippedData = fullData.slice(10);

                            setProgress("decode", 72, "æ ¡éªŒä¸­â€¦");
                            const calc = zippedData.reduce((a, b) => (a ^ b), 0) & 0xFF;
                            if (calc !== checksum) {
                                const goOn = confirm(`æ ¡éªŒå¤±è´¥ï¼šè®¡ç®—=${calc}ï¼Œè®°å½•=${checksum}ã€‚\næ•°æ®å¯èƒ½æŸåï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`);
                                if (!goOn) { cancel("ç”¨æˆ·å–æ¶ˆäº†è§£ç ã€‚"); return; }
                            }

                            setProgress("decode", 80, "è§£å‹ä¸­â€¦");
                            await uiTick();
                            fflate.unzip(zippedData, async (err, files) => {
                                if (err) {
                                    alert('è§£å‹å¤±è´¥ï¼š' + (err.message || err));
                                    hideProgress("decode", "å¤±è´¥");
                                    URL.revokeObjectURL(url);
                                    return;
                                }

                                const list = document.getElementById("fileList");
                                list.innerHTML = "";

                                const names = Object.keys(files);
                                if (names.length === 0) { list.textContent = "ï¼ˆè§£å‹æˆåŠŸï¼Œä½†å‹ç¼©åŒ…ä¸ºç©ºï¼‰"; finish(); return; }

                                const totalSize = names.reduce((s, n) => s + (files[n]?.length || 0), 0);
                                const summary = document.createElement("div");
                                summary.style.textAlign = "center";
                                summary.innerHTML = `ğŸ“ å…± ${names.length} ä¸ªæ–‡ä»¶<br>ğŸ“ è§£å‹åå¤§å°ï¼š${formatBytes(totalSize)}<br><br>`;
                                list.appendChild(summary);

                                // ä¸‹è½½ ZIPï¼ˆç›´æ¥ç”¨åµŒå…¥çš„ zippedDataï¼‰
                                const zipBlob = new Blob([zippedData], { type: "application/zip" });
                                const zipA = document.createElement("a");
                                zipA.href = URL.createObjectURL(zipBlob);
                                zipA.download = "qr_extracted.zip";
                                zipA.textContent = "ğŸ“¦ ä¸‹è½½æ•´ä¸ª ZIP";
                                Object.assign(zipA.style, {
                                    display: "inline-block", margin: "10px", padding: "10px",
                                    background: "#1976d2", color: "#fff", borderRadius: "6px", textDecoration: "none"
                                });
                                zipA.onclick = () => setTimeout(() => URL.revokeObjectURL(zipA.href), 2000);

                                // åˆ†å¼€ä¸‹è½½ï¼ˆåˆ†æ‰¹ï¼‰
                                const splitBtn = document.createElement("button");
                                splitBtn.textContent = "ğŸ“‚ åˆ†å¼€ä¸‹è½½å…¨éƒ¨æ–‡ä»¶";
                                Object.assign(splitBtn.style, {
                                    margin: "10px", padding: "10px", background: "#43a047",
                                    color: "#fff", border: "none", borderRadius: "6px", cursor: "pointer"
                                });
                                splitBtn.onclick = async () => {
                                    const batch = 10;
                                    for (let i = 0; i < names.length; i += batch) {
                                        const slice = names.slice(i, i + batch);
                                        setProgress("decode", 96, `é€ä¸ªä¸‹è½½â€¦ (${Math.min(i + batch, names.length)}/${names.length})`);
                                        for (const name of slice) {
                                            const blob = new Blob([files[name]]);
                                            const a = document.createElement("a");
                                            a.href = URL.createObjectURL(blob);
                                            a.download = name;
                                            a.style.display = "none";
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                            setTimeout(() => URL.revokeObjectURL(a.href), 2000);
                                        }
                                        await uiTick();
                                    }
                                    finish();
                                };

                                list.appendChild(zipA);
                                list.appendChild(splitBtn);
                                finish();

                                if (button) {
                                    button.disabled = false;
                                    button.innerText = originalText;
                                }
                            });
                        }
                    };

                    setProgress("decode", 8, "æ‰«æäºŒç»´ç æ•°æ®â€¦");
                    worker.postMessage({ type: 'scan', width, height, pixelsBuf: buf }, [buf]);
                } catch (err) {
                    alert(`æå–å¤±è´¥ï¼š${err.message}`);
                    hideProgress("decode", "å¤±è´¥");
                    try { worker.terminate(); } catch { }
                    URL.revokeObjectURL(url);
                }
            };

            await drawAndScan();
        }

        // è¾…åŠ©ï¼šå­—èŠ‚è½¬å‹å¥½å•ä½
        function formatBytes(n) {
            if (!Number.isFinite(n)) return n + " B";
            const units = ["B", "KB", "MB", "GB"];
            let i = 0;
            while (n >= 1024 && i < units.length - 1) {
                n /= 1024;
                i++;
            }
            return n.toFixed(n < 10 && i > 0 ? 1 : 0) + " " + units[i];
        }

        window.onload = () => {
            const status = document.getElementById("status");
            const loaded = typeof fflate !== "undefined" && typeof QRCode !== "undefined";

            if (loaded) {
                status.textContent = "ğŸŸ¢ æ‰€æœ‰ä¾èµ–åŠ è½½æˆåŠŸï¼Œå¯æ–­ç½‘ä½¿ç”¨";
                status.style.color = "limegreen";
            } else {
                status.textContent = "ğŸ”´ ä¾èµ–åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
                status.style.color = "red";
            }

            // æ§åˆ¶é™„åŠ æè¿°å›¾ç‰‡å’Œæè¿°çš„æ˜¾ç¤º
            document.getElementById("extraInfoToggle").onchange = (e) => {
                document.getElementById("extraInfoContainer").style.display = e.target.checked ? "block" : "none";
            };

            // æ–‡ä»¶åæ˜¾ç¤ºï¼šä¸Šä¼ æ–‡ä»¶ç»„
            const filesInput = document.getElementById("filesInput");
            filesInput.onchange = () => {
                const files = [...filesInput.files];
                const count = files.length;

                let displayText = "æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶";
                if (count === 1) {
                    displayText = `${files[0].name}ï¼ˆå…± 1 ä¸ªæ–‡ä»¶ï¼‰`;
                } else if (count === 2) {
                    displayText = `${files[0].name}, ${files[1].name}ï¼ˆå…± 2 ä¸ªæ–‡ä»¶ï¼‰`;
                } else if (count > 2) {
                    displayText = `${files[0].name}, ${files[1].name} ç­‰ ${count} ä¸ªæ–‡ä»¶`;
                }

                document.getElementById("filesInputName").textContent = displayText;
            };


            const imageInputName = document.getElementById("imageInputName");
            const imageInput = document.getElementById("imageInput");

            // é€‰æ‹©åæ›´æ–°æ–‡ä»¶å
            imageInput.onchange = () => {
                const name = imageInput.files[0]?.name || "æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡";
                imageInputName.textContent = name;
            };

            const previewName = document.getElementById("previewImageName");
            const previewInput = document.getElementById("previewImageInput");
            const clearBtn = document.getElementById("clearPreviewImageButton");

            // é€‰æ‹©åæ›´æ–°æ–‡ä»¶å
            previewInput.onchange = () => {
                const name = previewInput.files[0]?.name || "æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡";
                previewName.textContent = name;
            };

            // æ¸…é™¤æŒ‰é’®ï¼šç›´æ¥æŠŠ value ç½®ç©º
            clearBtn.onclick = () => {
                const input = document.getElementById("previewImageInput"); // æ¯æ¬¡ç°å–ï¼Œé¿å…æ‹¿åˆ°æ—§å¼•ç”¨
                if (!input) return;

                input.value = ""; // æ¸…ç©ºé€‰æ‹©
                previewName.textContent = "æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡";
            };
        };

        function setProgress(kind, pct, text) {
            const wrap = document.getElementById(kind + "ProgressWrap");
            const bar = document.getElementById(kind + "ProgressBar");
            const lbl = document.getElementById(kind + "ProgressText");
            if (!wrap || !bar || !lbl) return;
            wrap.style.display = "block";
            bar.style.width = Math.max(0, Math.min(100, pct)) + "%";
            if (text) lbl.textContent = text;
        }
        function hideProgress(kind, finalText) {
            const wrap = document.getElementById(kind + "ProgressWrap");
            const bar = document.getElementById(kind + "ProgressBar");
            const lbl = document.getElementById(kind + "ProgressText");
            if (!wrap) return;
            if (finalText && lbl) lbl.textContent = finalText;
            if (bar) bar.style.width = "100%";
            setTimeout(() => { wrap.style.display = "none"; }, 500);
        }
        function uiTick() { return new Promise(r => setTimeout(r)); }
        function formatBytes(n) {
            if (!Number.isFinite(n)) return n + " B";
            const units = ["B", "KB", "MB", "GB", "TB"];
            let i = 0, v = n;
            while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
            return v.toFixed(v < 10 && i > 0 ? 1 : 0) + " " + units[i];
        }

    </script>
</body>

</html>